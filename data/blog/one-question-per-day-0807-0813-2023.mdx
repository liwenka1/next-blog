---
title: 0807-0813 每日一题
date: '2023-08-07'
tags: ['算法', '每日一题', 'LeetCode']
draft: false
summary: '1.143. 重排链表 2.1749. 任意子数组和的绝对值的最大值 3.1281. 整数的各位积和之差 4.1289. 下降路径最小和  II 5.1572. 矩阵对角线元素的和 6.23. 合并 K 个升序链表 7.88. 合并两个有序数组'
layout: PostSimple
bibliography: references-data.bib
---

---

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/submissions/)

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function (s) {
  const n = s.length
  for (let i = 0; i < n / 2; i++) {
    ;[s[i], s[n - 1 - i]] = [s[n - 1 - i], s[i]]
  }
}
```

[1749. 任意子数组和的绝对值的最大值](https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/description/)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxAbsoluteSum = function (nums) {
  let ans = 0,
    max = 0,
    min = 0
  for (let num of nums) {
    max = Math.max(0, max) + num
    min = Math.min(0, min) + num
    ans = Math.max(ans, max, -min)
  }
  return ans
}

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxAbsoluteSum = function (nums) {
  let s = 0,
    max = 0,
    min = 0
  for (let num of nums) {
    s += num
    max = Math.max(max, s)
    min = Math.min(min, s)
  }
  return max - min
}
```

[1281. 整数的各位积和之差](https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer/)

```js
/**
 * @param {number} n
 * @return {number}
 */
var subtractProductAndSum = function (n) {
  n = n
    .toString()
    .split('')
    .map((i) => Number(i))
  let sum = 0
  let pdt = 1
  for (let i of n) {
    sum += i
    pdt *= i
  }
  return pdt - sum
}
```

[1289. 下降路径最小和 II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minFallingPathSum = function (grid) {
  const n = grid.length
  const dp = new Array(n).fill([]).map(() => new Array(n).fill(Infinity))
  for (let i = 0; i < n; i++) {
    dp[0][i] = grid[0][i]
  }
  for (let i = 1; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < n; k++) {
        if (k != j) dp[i][j] = Math.min(dp[i][j], grid[i][j] + dp[i - 1][k])
      }
    }
  }
  return Math.min(...dp[n - 1])
}
```

[1572. 矩阵对角线元素的和](https://leetcode.cn/problems/matrix-diagonal-sum/description/)

```js
/**
 * @param {number[][]} mat
 * @return {number}
 */
var diagonalSum = function (mat) {
  const n = mat.length
  let ans = 0
  for (let i = 0; i < n; i++) {
    if (i == n - 1 - i) ans += mat[i][i]
    else ans += mat[i][i] + mat[i][n - 1 - i]
  }
  return ans
}
```

[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

```js

```

[88. 合并两个有序数组](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
  let end = m + n - 1
  while (m - 1 >= 0 || n - 1 >= 0) {
    if (m - 1 < 0) nums1[end--] = nums2[n-- - 1]
    else if (n - 1 < 0) break
    else if (nums1[m - 1] < nums2[n - 1]) nums1[end--] = nums2[n-- - 1]
    else nums1[end--] = nums1[m-- - 1]
  }
}
```

---
