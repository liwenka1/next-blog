---
title: 0904-0910 每日一题
date: '2023-09-04'
tags: ['算法', '每日一题', 'LeetCode']
draft: false
summary: '1.449. 序列化和反序列化二叉搜索树 2.2605. 从两个数字数组里生成最小数字 3.1123. 最深叶节点的最近公共祖先 4.2594. 修车的最少时间'
layout: PostSimple
bibliography: references-data.bib
---

---

[449. 序列化和反序列化二叉搜索树](https://leetcode.cn/problems/serialize-and-deserialize-bst/description/)

```js

```

[2605. 从两个数字数组里生成最小数字](https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/description/)

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var minNumber = function (nums1, nums2) {
  nums1.sort((a, b) => a - b)
  const set = new Set(nums2)
  for (const x of nums1) {
    if (set.has(x)) return x
  }
  const min = Math.min(...nums2)
  return Math.min(min * 10 + nums1[0], nums1[0] * 10 + min)
}
```

[1123. 最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/description/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var lcaDeepestLeaves = function (root) {
  let ans = null
  let maxDepth = -1
  const dfs = (node, depth) => {
    if (node == null) {
      maxDepth = Math.max(maxDepth, depth)
      return depth
    }
    const leftDepth = dfs(node.left, depth + 1)
    const rightDepth = dfs(node.right, depth + 1)
    if (leftDepth == rightDepth && leftDepth == maxDepth) {
      ans = node
    }
    return Math.max(leftDepth, rightDepth)
  }
  dfs(root, 0)
  return ans
}
```

[2594. 修车的最少时间](https://leetcode.cn/problems/minimum-time-to-repair-cars/description/)

```js
/**
 * @param {number[]} ranks
 * @param {number} cars
 * @return {number}
 */
var repairCars = function (ranks, cars) {
  let left = 0
  let right = ranks[0] * cars * cars
  const check = (mid) => {
    let sum = 0
    for (const rank of ranks) {
      sum += Math.floor(Math.sqrt(mid / rank))
    }
    return sum >= cars
  }
  while (left < right) {
    const mid = Math.floor((left + right) / 2)
    if (check(mid)) {
      right = mid
    } else {
      left = mid + 1
    }
  }
  return left
}
```

---
