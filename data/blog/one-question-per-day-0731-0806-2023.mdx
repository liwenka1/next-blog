---
title: 0731-0805 每日一题
date: '2023-07-31'
tags: ['算法', '每日一题', 'LeetCode']
draft: false
summary: '1.143. 重排链表 2.2681. 英雄的力量 3.822. 翻转卡片游戏 4.722. 删除注释 5.980. 不同路径 III 6.21. 合并两个有序链表 7.24. 两两交换链表中的节点'
layout: PostSimple
bibliography: references-data.bib
---

---

[143. 重排链表](https://leetcode.cn/problems/reorder-list/)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {void} Do not return anything, modify head in-place instead.
 */

var reorderList = function (head) {
  let mid = midList(head)
  let reMid = reverseList(mid)
  while (reMid.next) {
    let nxt = head.next
    let reMidNxt = reMid.next
    head.next = reMid
    reMid.next = nxt
    head = nxt
    reMid = reMidNxt
  }
}

const midList = (head) => {
  let slow = head
  let fast = head
  while (fast && fast.next) {
    slow = slow.next
    fast = fast.next.next
  }
  return slow
}

const reverseList = (head) => {
  let pre = null
  while (head) {
    let nxt = head.next
    head.next = pre
    pre = head
    head = nxt
  }
  return pre
}
```

[2681. 英雄的力量](https://leetcode.cn/problems/power-of-heroes/)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var sumOfPower = function (nums) {
  nums.sort((a, b) => a - b)
  const MOD = 1e9 + 7
  let s = (ans = 0)
  for (let x of nums) {
    const bx = BigInt(x)
    ans += Number((bx * bx * (bx + BigInt(s))) % BigInt(MOD))
    s = (2 * s + x) % MOD
  }
  return ans % MOD
}
```

[822. 翻转卡片游戏](https://leetcode.cn/problems/card-flipping-game/)

```js
/**
 * @param {number[]} fronts
 * @param {number[]} backs
 * @return {number}
 */
var flipgame = function (fronts, backs) {
  const n = fronts.length
  const set = new Set()
  for (let i = 0; i < n; i++) {
    if (fronts[i] == backs[i]) set.add(fronts[i])
  }
  let ans = Infinity
  for (let i = 0; i < n; i++) {
    if (!set.has(fronts[i])) ans = Math.min(ans, fronts[i])
    if (!set.has(backs[i])) ans = Math.min(ans, backs[i])
  }
  return ans == Infinity ? 0 : ans
}
```

[722. 删除注释](https://leetcode.cn/problems/remove-comments/)

```js
/**
 * @param {string[]} source
 * @return {string[]}
 */
var removeComments = function (source) {
  let isBlock = false
  const ans = []
  let str = ''
  for (let s of source) {
    const n = s.length
    for (let i = 0; i < n; i++) {
      if (isBlock) {
        if (i + 1 < n && s[i] == '*' && s[i + 1] == '/') {
          isBlock = false
          i++
        }
      } else {
        if (i + 1 < n && s[i] == '/' && s[i + 1] == '/') {
          break
        } else if (i + 1 < n && s[i] == '/' && s[i + 1] == '*') {
          isBlock = true
          i++
        } else {
          str += s[i]
        }
      }
    }
    if (!isBlock && str.length) {
      ans.push(str)
      str = ''
    }
  }
  return ans
}
```

[980. 不同路径 III](https://leetcode.cn/problems/unique-paths-iii/)

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var uniquePathsIII = function (grid) {
  const m = grid.length
  const n = grid[0].length
  const step = [
    [0, 1],
    [0, -1],
    [1, 0],
    [-1, 0]
  ]
  let ans = 0
  const dfs = (i, j, cnt) => {
    if (grid[i][j] == 2) {
      if (cnt == 0) ans++
      return
    }
    grid[i][j] = -1
    for (let [x, y] of step) {
      if (
        i + x >= 0 &&
        i + x < m &&
        j + y >= 0 &&
        j + y < n &&
        grid[i + x][j + y] >= 0
      )
        dfs(i + x, j + y, cnt - 1)
    }
    grid[i][j] = 0
  }
  let starti = (startj = -1)
  let cnt = 1
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] == 1) {
        starti = i
        startj = j
      } else if (grid[i][j] == 0) {
        cnt++
      }
    }
  }
  dfs(starti, startj, cnt)
  return ans
}
```

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
  if (list1 == null) return list2
  if (list2 == null) return list1
  const cur = new ListNode()
  let pre = cur
  while (list1 != null && list2 != null) {
    const n1 = list1.val
    const n2 = list2.val
    if (n1 < n2) {
      pre.next = list1
      list1 = list1.next
    } else {
      pre.next = list2
      list2 = list2.next
    }
    pre = pre.next
  }
  pre.next = list1 == null ? list2 : list1
  return cur.next
}
```

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function (head) {
  if (head == null || head.next == null) return head
  const one = head
  const two = head.next
  const three = head.next.next
  two.next = one
  one.next = swapPairs(three)
  return two
}
```

---
